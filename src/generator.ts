import { mkdirSync, writeFileSync } from 'node:fs';
import { join } from 'node:path';
import type { AnalyzerOutput, TodoItem } from './types.js';

function safeWrite(filePath: string, content: string): void {
  try {
    writeFileSync(filePath, content);
  } catch (err) {
    throw new Error(`Failed to write ${filePath}: ${(err as Error).message}`, { cause: err });
  }
}

export function generate(output: AnalyzerOutput, outputDir: string): string[] {
  try {
    mkdirSync(join(outputDir, '.claude', 'skills'), { recursive: true });
  } catch (err) {
    throw new Error(`Cannot create output directory: ${outputDir}. ${(err as Error).message}`, { cause: err });
  }

  const files: string[] = [];

  // 1. insights-todo.md
  const todoPath = join(outputDir, 'insights-todo.md');
  safeWrite(todoPath, formatTodoTable(output.todos));
  files.push(todoPath);

  // 2. CLAUDE.md-additions.md
  const claudeMdPath = join(outputDir, 'CLAUDE.md-additions.md');
  safeWrite(claudeMdPath, output.claudeMdAdditions);
  files.push(claudeMdPath);

  // 3. settings-insights.json
  const settingsPath = join(outputDir, '.claude', 'settings-insights.json');
  safeWrite(settingsPath, JSON.stringify(output.settingsJson, null, 2));
  files.push(settingsPath);

  // 4. Skills (each in its own subdirectory)
  for (const skill of output.skills) {
    const skillDir = join(outputDir, '.claude', 'skills', skill.dirName);
    mkdirSync(skillDir, { recursive: true });
    const skillPath = join(skillDir, skill.filename);
    safeWrite(skillPath, skill.content);
    files.push(skillPath);
  }

  // 5. README
  const readmePath = join(outputDir, 'insights-README.md');
  safeWrite(readmePath, output.readmeContent);
  files.push(readmePath);

  return files;
}

function formatTodoTable(todos: TodoItem[]): string {
  let md = '# Insights To-Do List\n\n';
  md += '> Generated by claude-insights. Work through these tasks to reduce friction with Claude Code.\n\n';
  md += '| # | Task | Steps | Priority | Est Time | Expected Win |\n';
  md += '|---|------|-------|----------|----------|--------------|\n';

  for (let i = 0; i < todos.length; i++) {
    const t = todos[i];
    // Escape pipe chars in table cells, collapse newlines to <br>
    const steps = t.steps.replace(/\n/g, ' ').replace(/\|/g, '\\|');
    const task = t.task.replace(/\|/g, '\\|');
    const win = t.expectedWin.replace(/\|/g, '\\|');
    md += `| ${i + 1} | ${task} | ${steps} | ${t.priority} | ${t.estTime} | ${win} |\n`;
  }

  md += '\n## Priority Legend\n\n';
  md += '- **High**: Directly addresses top friction patterns — implement first\n';
  md += '- **Medium**: Improves workflow efficiency — implement after high-priority items\n';
  md += '- **Low**: Nice-to-have improvements — implement when convenient\n';

  return md;
}
