import type { ReportData, AnalyzerOutput, TodoItem, SkillFile, FrictionCategory, ClaudeMdItem, PatternCard } from './types.js';

export function analyze(data: ReportData): AnalyzerOutput {
  const skills = buildSkills(data);
  const todos = buildTodos(data, skills);
  const claudeMdAdditions = buildClaudeMdAdditions(data);
  const settingsJson = buildSettings(data);
  const readmeContent = buildReadme(skills);
  return { todos, claudeMdAdditions, settingsJson, skills, readmeContent };
}

/** Derive a short kebab-case skill name, stripping filler adjectives */
export function toSkillName(title: string): string {
  const fillerWords = new Set([
    'repeated', 'incorrect', 'missing', 'wrong', 'premature', 'frequent', 'common',
    'excessive', 'unnecessary', 'various', 'multiple',
    'and', 'the', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'without',
  ]);
  return title
    .toLowerCase()
    .replace(/[^a-z0-9\s-]/g, '')
    .split(/\s+/)
    .filter(w => w.length > 0 && !fillerWords.has(w))
    .join('-')
    .replace(/-+/g, '-')
    .replace(/^-|-$/g, '')
    .slice(0, 40);
}

export function buildTodos(data: ReportData, skills: SkillFile[]): TodoItem[] {
  const todos: TodoItem[] = [];

  // Friction-derived tasks (High priority) — one per friction, linked to its generated skill
  for (let i = 0; i < data.frictions.length; i++) {
    const friction = data.frictions[i];
    const skill = skills[i];
    const skillCmd = skill ? `/${toSkillName(friction.title)}` : '';
    todos.push({
      task: `Address friction: "${friction.title}"`,
      steps: skill
        ? `1. Copy relevant rules from CLAUDE.md-additions.md to your CLAUDE.md\n2. Copy ${skill.dirName}/${skill.filename} to .claude/skills/${skill.dirName}/\n3. Test: run ${skillCmd} on your next relevant task`
        : `1. Review the friction description\n2. Add guardrail rules to your CLAUDE.md`,
      priority: 'High',
      estTime: '5 min',
      expectedWin: `Reduces "${friction.title}" friction pattern`,
      source: 'friction',
    });
  }

  // CLAUDE.md item tasks (High priority)
  for (const item of data.claudeMdItems) {
    const shortCode = item.code.length > 80 ? item.code.slice(0, 80) + '...' : item.code;
    todos.push({
      task: `Add CLAUDE.md rule: "${shortCode}"`,
      steps: '1. Open your project CLAUDE.md\n2. Paste the rule under the appropriate section\n3. Save',
      priority: 'High',
      estTime: '2 min',
      expectedWin: 'Prevents repeated friction pattern',
      source: 'claude-md',
    });
  }

  // Feature tasks (Medium priority)
  for (const feature of data.features) {
    todos.push({
      task: `Set up ${feature.title}`,
      steps: feature.examples.length > 0
        ? `1. Review the example in the generated files\n2. Copy configuration to your project\n3. Test it works`
        : `1. Read the feature description\n2. Configure in your project\n3. Test`,
      priority: 'Medium',
      estTime: '10 min',
      expectedWin: feature.oneliner,
      source: 'feature',
    });
  }

  // Pattern tasks (Medium/Low priority)
  for (const pattern of data.patterns) {
    todos.push({
      task: `Try workflow: ${pattern.title}`,
      steps: '1. Copy the suggested prompt from insights-README.md\n2. Paste it at the start of your next relevant session\n3. Evaluate if it reduces friction',
      priority: 'Medium',
      estTime: '5 min',
      expectedWin: pattern.summary,
      source: 'pattern',
    });
  }

  return todos;
}

export function buildClaudeMdAdditions(data: ReportData): string {
  // Categorize CLAUDE.md items by detecting keywords in their code
  const sections: Record<string, { code: string; why: string }[]> = {
    'General Rules': [],
    'CSS & Styling': [],
    'Testing': [],
    'Debugging': [],
  };

  for (const item of data.claudeMdItems) {
    const lower = item.code.toLowerCase();
    if (lower.includes('css') || lower.includes('shadow dom') || lower.includes('styling') || lower.includes('scoped')) {
      sections['CSS & Styling'].push(item);
    } else if (lower.includes('test') || lower.includes('playwright') || lower.includes('vitest') || lower.includes('mock')) {
      sections['Testing'].push(item);
    } else if (lower.includes('debug') || lower.includes('root cause') || lower.includes('reproduce') || lower.includes('diagnostic')) {
      sections['Debugging'].push(item);
    } else {
      sections['General Rules'].push(item);
    }
  }

  let md = '# CLAUDE.md Additions\n\n';
  md += '> Generated by claude-insights. Copy the relevant sections into your project\'s CLAUDE.md.\n\n';

  for (const [section, items] of Object.entries(sections)) {
    if (items.length === 0) continue;
    md += `## ${section}\n\n`;
    for (const item of items) {
      md += `${item.code}\n\n`;
      if (item.why) {
        md += `> _Why: ${item.why}_\n\n`;
      }
    }
  }

  return md;
}

export function buildSettings(data: ReportData): Record<string, unknown> {
  // Extract hook configurations from feature examples
  const hooksFeature = data.features.find(f => f.title.toLowerCase().includes('hook'));

  if (hooksFeature && hooksFeature.examples.length > 0) {
    // Try to extract JSON from the example code
    const example = hooksFeature.examples[0];
    const jsonMatch = example.match(/\{[\s\S]*"hooks"[\s\S]*\}/);
    if (jsonMatch) {
      try {
        // Clean up the example — remove JS comments
        const cleaned = jsonMatch[0].replace(/\/\/.*$/gm, '').trim();
        return JSON.parse(cleaned);
      } catch {
        // Fallback to a sensible default based on the report content
      }
    }
  }

  // No hooks feature found in report — return empty config
  return {};
}

export function buildSkills(data: ReportData): SkillFile[] {
  const skills: SkillFile[] = [];

  for (const friction of data.frictions) {
    const skillName = toSkillName(friction.title);
    const dirName = skillName;
    const filename = 'SKILL.md';

    const matchingPattern = findBestMatch(friction.title, data.patterns.map(p => ({ text: p.title, item: p })));
    const matchingRule = findBestMatch(friction.title, data.claudeMdItems.map(c => ({ text: c.code, item: c })));

    const description = buildTriggerDescription(friction);
    const steps = buildSkillSteps(friction, matchingPattern);
    const rules = buildSkillRules(matchingRule, friction);
    const whenToUse = buildWhenToUse(friction);
    const examples = buildSkillExamples(friction.examples);
    const checklist = buildVerificationChecklist(friction);

    // Format description: use YAML block scalar for multi-line, inline for single-line
    const descYaml = description.includes('\n')
      ? `|\n  ${description.replace(/\n/g, '\n  ')}`
      : description;

    skills.push({
      skillName,
      dirName,
      filename,
      content: `---
name: ${skillName}
description: ${descYaml}
allowed-tools: ["Read", "Glob", "Grep", "Bash"]
context: fork
argument-hint: "<file-or-component-path>"
---

## When to Use This Skill

${whenToUse}

## Steps

${steps}

## Rules

${rules}

${examples}## Verification Checklist

${checklist}

## Why This Skill Exists

${friction.description}
`,
    });
  }

  return skills;
}

/** Build a multi-line trigger-rich description with scenario phrases */
export function buildTriggerDescription(friction: FrictionCategory): string {
  let desc = `Use when encountering ${friction.title.toLowerCase()}`;

  // Extract scenario phrases from examples for richer triggers
  const scenarios = friction.examples
    .map(extractScenarioPhrase)
    .filter((s): s is string => s !== null)
    .slice(0, 3);

  if (scenarios.length > 0) {
    desc += `,\nespecially ${scenarios.join(', ')}`;
  } else {
    // Fallback to keyword-based triggers if no parseable scenarios
    const titleWords = significantWords(friction.title);
    const triggerWords = extractTriggerTerms(friction)
      .filter(w => !titleWords.includes(w));
    const uniqueTerms = [...new Set(triggerWords)].slice(0, 5);
    if (uniqueTerms.length > 0) {
      desc += `,\ninvolving ${uniqueTerms.join(', ')}`;
    }
  }

  desc += '.';
  return desc;
}

/** Extract a short scenario phrase from a friction example */
export function extractScenarioPhrase(example: string): string | null {
  // Match "When [doing X], Claude..." or "When [doing X], the..."
  const whenMatch = example.match(/^When\s+(.{10,100}?)(?:,\s+Claude|,\s+the\s|,\s+CSS|,\s+pseudo)/i);
  if (whenMatch) return whenMatch[1].trim().toLowerCase();

  // Match up to the first comma NOT inside parentheses
  // (?:[^,(]|\([^)]*\)) matches a non-comma/non-paren char OR a complete (...) group
  const commaMatch = example.match(/^((?:[^,(]|\([^)]*\)){10,100}?)(?:,)/);
  if (commaMatch) return commaMatch[1].trim().toLowerCase();

  return null;
}

/** Extract technical/domain-specific trigger terms, filtering generic verbs */
export function extractTriggerTerms(friction: FrictionCategory): string[] {
  const genericVerbs = new Set([
    'when', 'why', 'how', 'what', 'where', 'which',
    'fixing', 'fixed', 'fix', 'implementing', 'implemented', 'implement',
    'using', 'used', 'use', 'making', 'made', 'make',
    'working', 'worked', 'work', 'adding', 'added', 'add',
    'getting', 'got', 'get', 'trying', 'tried', 'try',
    'running', 'ran', 'run', 'setting', 'set', 'first',
    'still', 'then', 'just', 'only', 'also', 'many',
    'multiple', 'several', 'various', 'caused', 'causing',
    'required', 'requiring', 'needed', 'left', 'spent',
    'claude', 'claudes', 'session', 'sessions', 'approach',
    'issue', 'issues', 'problem', 'problems', 'initially',
  ]);
  const allText = [...friction.examples, friction.description].join(' ');
  return allText
    .toLowerCase()
    .replace(/[^a-z0-9\s-]/g, '')
    .split(/\s+/)
    .filter(w => w.length > 2 && !genericVerbs.has(w) && !stopWordsSet.has(w));
}

const stopWordsSet = new Set(['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for',
  'of', 'with', 'by', 'from', 'is', 'are', 'was', 'were', 'be', 'been', 'being',
  'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could', 'should',
  'not', 'no', 'without', 'before', 'after', 'about', 'that', 'this', 'it']);

/** Build structured verify-first steps, with optional pattern prompt as starting context */
export function buildSkillSteps(friction: FrictionCategory, pattern: PatternCard | undefined): string {
  const steps: string[] = [];

  steps.push(`**Diagnose**: Read the relevant files and map the existing patterns related to ${friction.title.toLowerCase()}. Identify boundaries, ownership, and current behavior before changing anything.`);
  steps.push('**Identify constraints**: List what must NOT change, which components or modules are affected, and document your assumptions. Get confirmation before proceeding.');
  steps.push('**Propose approach**: Describe your planned fix and explain why it avoids the known failure patterns listed in "What Goes Wrong" below. Wait for approval.');
  steps.push('**Implement**: Apply the most minimal, narrowly-scoped change possible. Prefer the smallest edit that solves the problem.');
  steps.push('**Verify**: Confirm the fix works AND doesn\'t regress related components. Check against each example in "What Goes Wrong". Run relevant tests.');

  let output = steps.map((s, i) => `${i + 1}. ${s}`).join('\n');

  if (pattern) {
    output += `\n\n### Suggested Starting Prompt\n\n> ${pattern.prompt}`;
  }

  return output;
}

/** Parse a CLAUDE.md rule into bullet points, with fallback rules from friction context */
export function buildSkillRules(rule: ClaudeMdItem | undefined, friction: FrictionCategory): string {
  const bullets: string[] = [];

  if (rule) {
    bullets.push(...parseRuleIntoBullets(rule.code));
  }

  // Add fallback domain-specific rules when no CLAUDE.md rule matched
  if (bullets.length === 0) {
    const domainWords = significantWords(friction.title).slice(0, 3);
    const domainHint = domainWords.length > 0 ? domainWords.join(', ') : 'existing';
    bullets.push(`Always inspect and reference existing ${domainHint} patterns before proposing a solution`);
    bullets.push('Do NOT apply broad or global changes — use the narrowest possible scope');
  }

  // Only append universal guardrails if not already covered by parsed rules
  const existingText = bullets.join(' ').toLowerCase();
  if (!existingText.includes('regress') && !existingText.includes('don\'t break') && !existingText.includes('doesn\'t affect')) {
    bullets.push('After implementing, verify the fix doesn\'t regress related components or sibling functionality');
  }
  if (!existingText.includes('confirm') && !existingText.includes('approval') && !existingText.includes('before applying')) {
    bullets.push('Before applying changes, list affected components and get confirmation');
  }

  return bullets.map(b => `- ${b}`).join('\n');
}

/** Split a rule string into individual bullet-point items */
export function parseRuleIntoBullets(code: string): string[] {
  // Try numbered items: "1) item, 2) item" or "1. item"
  const numberedItems = code.match(/\d+[).]\s*[^,;)]+/g);
  if (numberedItems && numberedItems.length >= 2) {
    return numberedItems.map(item =>
      item.replace(/^\d+[).]\s*/, '').replace(/,\s*$/, '').trim()
    ).filter(s => s.length > 5);
  }

  // Try splitting by sentences
  const sentences = code.split(/\.\s+/).filter(s => s.trim().length > 10);
  if (sentences.length >= 2) {
    return sentences.map(s => s.trim().replace(/\.$/, ''));
  }

  // Single rule as-is
  return [code.trim()];
}

/** Format friction examples with bolded technical terms */
export function buildSkillExamples(examples: string[]): string {
  if (examples.length === 0) return '';

  let md = '## What Goes Wrong\n\n';
  md += 'Review these failure patterns before implementing. Your fix must not repeat them:\n\n';
  for (const example of examples) {
    md += `- ${boldTechTerms(example)}\n`;
  }
  md += '\n';
  return md;
}

/** Bold key technical terms in example text for scanability */
export function boldTechTerms(text: string): string {
  return text
    // Bold CSS pseudo-selectors like :has(), ::before
    .replace(/(::?[a-z-]+\([^)]*\))/g, '**$1**')
    // Bold dimensions like 0×0
    .replace(/\b(\d+[×x]\d+)\b/g, '**$1**')
    // Bold multi-word uppercase sequences as phrases (e.g., "LEFT JOIN", "INNER JOIN", "Shadow DOM")
    .replace(/(?<=[\s,(])([A-Z][A-Za-z]*(?:\s+[A-Z][A-Za-z]*)+)(?=[\s,.):])/g, '**$1**')
    // Bold remaining standalone acronyms (2+ uppercase) not already inside **
    .replace(/(?<!\*\*)(?<=[\s,(])([A-Z]{2,})(?=[\s,.):])/g, '**$1**');
}

/** Build a verification checklist from friction examples */
export function buildVerificationChecklist(friction: FrictionCategory): string {
  const checks: string[] = [];

  checks.push('- [ ] Fix addresses the specific issue the user reported');
  checks.push('- [ ] Change follows existing codebase patterns found during diagnosis');
  checks.push('- [ ] Change is narrowly scoped — minimal blast radius');
  checks.push('- [ ] Related/sibling components verified — no regressions');

  for (const example of friction.examples.slice(0, 3)) {
    const short = example.length > 100
      ? example.slice(0, 100).replace(/\s+\S*$/, '') + '...'
      : example;
    checks.push(`- [ ] Verified against: "${short}"`);
  }

  checks.push('- [ ] Approach was proposed and confirmed before implementation');

  return checks.join('\n');
}

/** Auto-generate "When to Use" triggers from friction title + examples */
export function buildWhenToUse(friction: FrictionCategory): string {
  const triggers: string[] = [];

  // Primary trigger from title
  triggers.push(`When a task involves ${friction.title.toLowerCase()}.`);

  // Scenario-based triggers from examples
  for (const example of friction.examples.slice(0, 3)) {
    const phrase = extractScenarioPhrase(example);
    if (phrase) {
      triggers.push(`When ${phrase}.`);
    }
  }

  // Fallback: description-based trigger
  if (triggers.length === 1) {
    const descWords = significantWords(friction.description).slice(0, 4);
    if (descWords.length > 0) {
      triggers.push(`When previous attempts involved ${descWords.join(', ')} issues.`);
    }
  }

  return triggers.map(t => `- ${t}`).join('\n');
}

/** Find the best matching item by checking for shared significant words */
export function findBestMatch<T>(title: string, candidates: { text: string; item: T }[]): T | undefined {
  const titleWords = significantWords(title);
  let bestMatch: T | undefined;
  let bestScore = 0;

  for (const candidate of candidates) {
    const candidateWords = significantWords(candidate.text);
    const overlap = titleWords.filter(w => candidateWords.includes(w)).length;
    if (overlap > bestScore) {
      bestScore = overlap;
      bestMatch = candidate.item;
    }
  }

  return bestScore >= 1 ? bestMatch : undefined;
}

/** Extract significant words (skip common stop words) */
export function significantWords(text: string): string[] {
  const stopWords = new Set(['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for',
    'of', 'with', 'by', 'from', 'is', 'are', 'was', 'were', 'be', 'been', 'being',
    'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could', 'should',
    'not', 'no', 'without', 'before', 'after', 'about', 'that', 'this', 'it']);
  return text.toLowerCase().replace(/[^a-z0-9\s]/g, '').split(/\s+/).filter(w => w.length > 2 && !stopWords.has(w));
}

export function buildReadme(skills: SkillFile[]): string {
  const skillRows = skills.map(s => {
    return `| \`.claude/skills/${s.dirName}/SKILL.md\` | \`/${s.skillName}\` skill | Copy to your project's \`.claude/skills/\` |`;
  }).join('\n');

  const skillTests = skills.map(s => {
    // Extract first line of description from frontmatter (handles both inline and multi-line |)
    const lines = s.content.split('\n');
    const descIdx = lines.findIndex(l => l.startsWith('description:'));
    let desc = s.skillName;
    if (descIdx !== -1) {
      const descLine = lines[descIdx];
      if (descLine.includes('|')) {
        // Multi-line YAML: first content line is next non-empty indented line
        desc = (lines[descIdx + 1] || '').trim();
      } else {
        desc = descLine.replace('description:', '').trim();
      }
    }
    return `- \`/${s.skillName}\` — ${desc}`;
  }).join('\n');

  const firstSkillName = skills.length > 0 ? skills[0].skillName : 'insights-review';

  return `# Insights Output — Placement Guide

## Generated Files

| File | What It Is | Where To Put It |
|------|-----------|-----------------|
| \`CLAUDE.md-additions.md\` | Rules for Claude based on your friction patterns | Copy contents into your project's root \`CLAUDE.md\` |
| \`insights-todo.md\` | Prioritized task list with steps | Keep as reference, work through tasks |
| \`.claude/settings-insights.json\` | Hook configurations | Merge into your \`.claude/settings.json\` |
${skillRows}

## Quick Start

1. **CLAUDE.md**: Open \`CLAUDE.md-additions.md\`, copy the rules you want into your project's \`CLAUDE.md\`
2. **Settings**: Open \`.claude/settings-insights.json\`, merge the hooks config into your existing \`.claude/settings.json\`
3. **Skills**: Copy the \`.claude/skills/\` directories into your project's \`.claude/skills/\` directory
4. **Test**: Start a new Claude Code session and try \`/${firstSkillName}\` on your next task

## Testing Skills

${skillTests}
`;
}
