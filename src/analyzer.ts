import type { ReportData, AnalyzerOutput, TodoItem, SkillFile } from './types.js';

export function analyze(data: ReportData): AnalyzerOutput {
  const skills = buildSkills(data);
  const todos = buildTodos(data, skills);
  const claudeMdAdditions = buildClaudeMdAdditions(data);
  const settingsJson = buildSettings(data);
  const readmeContent = buildReadme(skills);
  return { todos, claudeMdAdditions, settingsJson, skills, readmeContent };
}

/** Derive a kebab-case skill name from a friction title */
function toSkillName(title: string): string {
  return title
    .toLowerCase()
    .replace(/[^a-z0-9\s-]/g, '')
    .replace(/\s+/g, '-')
    .replace(/-+/g, '-')
    .replace(/^-|-$/g, '')
    .slice(0, 40);
}

function buildTodos(data: ReportData, skills: SkillFile[]): TodoItem[] {
  const todos: TodoItem[] = [];

  // Friction-derived tasks (High priority) — one per friction, linked to its generated skill
  for (let i = 0; i < data.frictions.length; i++) {
    const friction = data.frictions[i];
    const skill = skills[i];
    const skillCmd = skill ? `/${toSkillName(friction.title)}` : '';
    todos.push({
      task: `Address friction: "${friction.title}"`,
      steps: skill
        ? `1. Copy relevant rules from CLAUDE.md-additions.md to your CLAUDE.md\n2. Copy ${skill.filename} to .claude/skills/\n3. Test: run ${skillCmd} on your next relevant task`
        : `1. Review the friction description\n2. Add guardrail rules to your CLAUDE.md`,
      priority: 'High',
      estTime: '5 min',
      expectedWin: `Reduces "${friction.title}" friction pattern`,
      source: 'friction',
    });
  }

  // CLAUDE.md item tasks (High priority)
  for (const item of data.claudeMdItems) {
    const shortCode = item.code.length > 80 ? item.code.slice(0, 80) + '...' : item.code;
    todos.push({
      task: `Add CLAUDE.md rule: "${shortCode}"`,
      steps: '1. Open your project CLAUDE.md\n2. Paste the rule under the appropriate section\n3. Save',
      priority: 'High',
      estTime: '2 min',
      expectedWin: 'Prevents repeated friction pattern',
      source: 'claude-md',
    });
  }

  // Feature tasks (Medium priority)
  for (const feature of data.features) {
    todos.push({
      task: `Set up ${feature.title}`,
      steps: feature.examples.length > 0
        ? `1. Review the example in the generated files\n2. Copy configuration to your project\n3. Test it works`
        : `1. Read the feature description\n2. Configure in your project\n3. Test`,
      priority: 'Medium',
      estTime: '10 min',
      expectedWin: feature.oneliner,
      source: 'feature',
    });
  }

  // Pattern tasks (Medium/Low priority)
  for (const pattern of data.patterns) {
    todos.push({
      task: `Try workflow: ${pattern.title}`,
      steps: '1. Copy the suggested prompt from insights-README.md\n2. Paste it at the start of your next relevant session\n3. Evaluate if it reduces friction',
      priority: 'Medium',
      estTime: '5 min',
      expectedWin: pattern.summary,
      source: 'pattern',
    });
  }

  return todos;
}

function buildClaudeMdAdditions(data: ReportData): string {
  // Categorize CLAUDE.md items by detecting keywords in their code
  const sections: Record<string, { code: string; why: string }[]> = {
    'General Rules': [],
    'CSS & Styling': [],
    'Testing': [],
    'Debugging': [],
  };

  for (const item of data.claudeMdItems) {
    const lower = item.code.toLowerCase();
    if (lower.includes('css') || lower.includes('shadow dom') || lower.includes('styling') || lower.includes('scoped')) {
      sections['CSS & Styling'].push(item);
    } else if (lower.includes('test') || lower.includes('playwright') || lower.includes('vitest') || lower.includes('mock')) {
      sections['Testing'].push(item);
    } else if (lower.includes('debug') || lower.includes('root cause') || lower.includes('reproduce') || lower.includes('diagnostic')) {
      sections['Debugging'].push(item);
    } else {
      sections['General Rules'].push(item);
    }
  }

  let md = '# CLAUDE.md Additions\n\n';
  md += '> Generated by claude-insights. Copy the relevant sections into your project\'s CLAUDE.md.\n\n';

  for (const [section, items] of Object.entries(sections)) {
    if (items.length === 0) continue;
    md += `## ${section}\n\n`;
    for (const item of items) {
      md += `${item.code}\n\n`;
      if (item.why) {
        md += `> _Why: ${item.why}_\n\n`;
      }
    }
  }

  return md;
}

function buildSettings(data: ReportData): object {
  // Extract hook configurations from feature examples
  const hooksFeature = data.features.find(f => f.title.toLowerCase().includes('hook'));

  if (hooksFeature && hooksFeature.examples.length > 0) {
    // Try to extract JSON from the example code
    const example = hooksFeature.examples[0];
    const jsonMatch = example.match(/\{[\s\S]*"hooks"[\s\S]*\}/);
    if (jsonMatch) {
      try {
        // Clean up the example — remove JS comments
        const cleaned = jsonMatch[0].replace(/\/\/.*$/gm, '').trim();
        return JSON.parse(cleaned);
      } catch {
        // Fallback to a sensible default based on the report content
      }
    }
  }

  // No hooks feature found in report — return empty config
  return {};
}

function buildSkills(data: ReportData): SkillFile[] {
  const skills: SkillFile[] = [];

  // Generate one skill per friction — fully dynamic
  for (const friction of data.frictions) {
    const skillName = toSkillName(friction.title);
    const filename = `${skillName}.SKILL.md`;

    // Try to find a matching pattern (prompt to use as instructions)
    const matchingPattern = findBestMatch(friction.title, data.patterns.map(p => ({ text: p.title, item: p })));
    // Try to find a matching CLAUDE.md rule
    const matchingRule = findBestMatch(friction.title, data.claudeMdItems.map(c => ({ text: c.code, item: c })));

    const instructions = matchingPattern
      ? matchingPattern.prompt
      : `Before addressing issues related to "${friction.title}", first:\n1. Read the relevant files and understand the existing patterns\n2. List your assumptions and constraints for confirmation\n3. Propose your approach before implementing`;

    const rulesSection = matchingRule
      ? `\n## Rules\n\n${matchingRule.code}\n`
      : '';

    skills.push({
      filename,
      content: `---
name: ${skillName}
description: ${friction.title}
---

## Instructions

${instructions}
${rulesSection}
## Why This Exists

${friction.description}

## Examples of What Goes Wrong

${friction.examples.length > 0 ? friction.examples.map(e => `- ${e}`).join('\n') : '- No specific examples extracted'}
`,
    });
  }

  return skills;
}

/** Find the best matching item by checking for shared significant words */
function findBestMatch<T>(title: string, candidates: { text: string; item: T }[]): T | undefined {
  const titleWords = significantWords(title);
  let bestMatch: T | undefined;
  let bestScore = 0;

  for (const candidate of candidates) {
    const candidateWords = significantWords(candidate.text);
    const overlap = titleWords.filter(w => candidateWords.includes(w)).length;
    if (overlap > bestScore) {
      bestScore = overlap;
      bestMatch = candidate.item;
    }
  }

  return bestScore >= 1 ? bestMatch : undefined;
}

/** Extract significant words (skip common stop words) */
function significantWords(text: string): string[] {
  const stopWords = new Set(['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for',
    'of', 'with', 'by', 'from', 'is', 'are', 'was', 'were', 'be', 'been', 'being',
    'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could', 'should',
    'not', 'no', 'without', 'before', 'after', 'about', 'that', 'this', 'it']);
  return text.toLowerCase().replace(/[^a-z0-9\s]/g, '').split(/\s+/).filter(w => w.length > 2 && !stopWords.has(w));
}

function buildReadme(skills: SkillFile[]): string {
  const skillRows = skills.map(s => {
    const name = s.filename.replace('.SKILL.md', '');
    return `| \`.claude/skills/${s.filename}\` | \`/${name}\` skill | Copy to your project's \`.claude/skills/\` |`;
  }).join('\n');

  const skillTests = skills.map(s => {
    const name = s.filename.replace('.SKILL.md', '');
    // Extract description from frontmatter
    const descMatch = s.content.match(/description:\s*(.+)/);
    const desc = descMatch ? descMatch[1].trim() : name;
    return `- \`/${name}\` — ${desc}`;
  }).join('\n');

  const firstSkillName = skills.length > 0 ? skills[0].filename.replace('.SKILL.md', '') : 'insights-review';

  return `# Insights Output — Placement Guide

## Generated Files

| File | What It Is | Where To Put It |
|------|-----------|-----------------|
| \`CLAUDE.md-additions.md\` | Rules for Claude based on your friction patterns | Copy contents into your project's root \`CLAUDE.md\` |
| \`insights-todo.md\` | Prioritized task list with steps | Keep as reference, work through tasks |
| \`.claude/settings-insights.json\` | Hook configurations | Merge into your \`.claude/settings.json\` |
${skillRows}

## Quick Start

1. **CLAUDE.md**: Open \`CLAUDE.md-additions.md\`, copy the rules you want into your project's \`CLAUDE.md\`
2. **Settings**: Open \`.claude/settings-insights.json\`, merge the hooks config into your existing \`.claude/settings.json\`
3. **Skills**: Copy the \`.claude/skills/*.SKILL.md\` files into your project's \`.claude/skills/\` directory
4. **Test**: Start a new Claude Code session and try \`/${firstSkillName}\` on your next task

## Testing Skills

${skillTests}
`;
}
